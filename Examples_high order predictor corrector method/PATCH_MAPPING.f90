MODULE PATCH_MAPPING

	USE GLBVAR
	
	IMPLICIT NONE

CONTAINS

! Mapping from [-1, 1] to Limts of Integration
!----------------------------------------------------------------------------------------
TYPE(FUNCTION_1D) FUNCTION REFLINE_TO_PHYLINE(REFPT, PHYLINE)
	REAL*8, INTENT(IN) :: REFPT, PHYLINE(1:2)
	
	REFLINE_TO_PHYLINE%VAL(0) = 0.50D0*(PHYLINE(2) - PHYLINE(1))*(REFPT + 1.0D0) + PHYLINE(1)
	REFLINE_TO_PHYLINE%VAL(1) = 0.50D0*(PHYLINE(2) - PHYLINE(1))
	REFLINE_TO_PHYLINE%VAL(2) = 0.0D0
	
END FUNCTION REFLINE_TO_PHYLINE


! MAPPING [0, 1] TO PATCH
!----------------------------------------------------------------------------------------
TYPE(FUNCTION_1D) FUNCTION UNITLINE_TO_PATCH(REFPT, PATCH)
	
	REAL*8, INTENT(IN) :: REFPT
	INTEGER, INTENT(IN) :: PATCH
	
	REAL*8 :: LEFT_PT, RIGHT_PT

	IF (NUMPATCH==1) THEN 
		UNITLINE_TO_PATCH%VAL(0) = REFPT
		UNITLINE_TO_PATCH%VAL(1) = 1.0D0
		UNITLINE_TO_PATCH%VAL(2) = 0.0D0
		GOTO 76
	ENDIF
	
	IF (PATCH==NUMPATCH) THEN
		LEFT_PT = PATCHBDPT(PATCH,1) - DELTA
		RIGHT_PT = PATCHBDPT(PATCH,2)
	ELSEIF (PATCH==1) THEN
		LEFT_PT = PATCHBDPT(PATCH,1)
		RIGHT_PT = PATCHBDPT(PATCH,2) + DELTA
	ELSE
		LEFT_PT = PATCHBDPT(PATCH,1) - DELTA
		RIGHT_PT = PATCHBDPT(PATCH,2) + DELTA
	ENDIF
	
	UNITLINE_TO_PATCH%VAL(0) = (RIGHT_PT - LEFT_PT)*REFPT + LEFT_PT
	UNITLINE_TO_PATCH%VAL(1) = (RIGHT_PT - LEFT_PT)
	UNITLINE_TO_PATCH%VAL(2) = 0.0D0
	
	76 CONTINUE
	
END FUNCTION UNITLINE_TO_PATCH


! MAPPING PATCH TO [0, 1]
!----------------------------------------------------------------------------------------
TYPE(FUNCTION_1D) FUNCTION PATCH_TO_UNITLINE(PHYPT, PATCH)

	REAL*8, INTENT(IN) :: PHYPT
	INTEGER, INTENT(IN) :: PATCH
	
	REAL*8 :: LEFT_PT, RIGHT_PT
	
	IF (NUMPATCH==1) THEN 
		PATCH_TO_UNITLINE%VAL(0) = PHYPT
		PATCH_TO_UNITLINE%VAL(1) = 1.0D0
		PATCH_TO_UNITLINE%VAL(2) = 0.0D0
		GOTO 76
	ENDIF
	
	IF (PATCH==NUMPATCH) THEN
		LEFT_PT = PATCHBDPT(PATCH,1) - DELTA
		RIGHT_PT = PATCHBDPT(PATCH,2)
	ELSEIF (PATCH==1) THEN
		LEFT_PT = PATCHBDPT(PATCH,1)
		RIGHT_PT = PATCHBDPT(PATCH,2) + DELTA
	ELSE
		LEFT_PT = PATCHBDPT(PATCH,1) - DELTA
		RIGHT_PT = PATCHBDPT(PATCH,2) + DELTA
	ENDIF
	
	PATCH_TO_UNITLINE%VAL(0) = (PHYPT - LEFT_PT)/(RIGHT_PT - LEFT_PT)
	PATCH_TO_UNITLINE%VAL(1) = 1.0D0/(RIGHT_PT - LEFT_PT)
	PATCH_TO_UNITLINE%VAL(2) = 0.0D0
	
	76 CONTINUE
	
END FUNCTION PATCH_TO_UNITLINE



! MAPPING PATCH TO [-1, 1]
TYPE(FUNCTION_1D) FUNCTION PATCH_TO_REF1D(X, PATCH)

	REAL*8, INTENT(IN) :: X
	INTEGER, INTENT(IN) :: PATCH
	
	REAL*8 :: LEFT_PT, RIGHT_PT
	
	IF (NUMPATCH==1) THEN 
		LEFT_PT  = PATCHBDPT(PATCH,1)
		RIGHT_PT = PATCHBDPT(PATCH,2)
	ELSE 
		IF (PATCH==1) THEN
			LEFT_PT  = PATCHBDPT(PATCH,1)
			RIGHT_PT = PATCHBDPT(PATCH,2) + DELTA
		ELSEIF (PATCH==NUMPATCH) THEN
			LEFT_PT  = PATCHBDPT(PATCH,1) - DELTA
			RIGHT_PT = PATCHBDPT(PATCH,2)
		ELSE 
			LEFT_PT  = PATCHBDPT(PATCH,1) - DELTA
			RIGHT_PT = PATCHBDPT(PATCH,2) + DELTA
		ENDIF
	ENDIF
	
	PATCH_TO_REF1D%VAL(0) = (2.0D0/(RIGHT_PT - LEFT_PT))*(X - LEFT_PT) - 1.0D0
	PATCH_TO_REF1D%VAL(1) = (2.0D0/(RIGHT_PT - LEFT_PT))*(X - LEFT_PT)
	PATCH_TO_REF1D%VAL(2) = 0.0D0
	
END FUNCTION PATCH_TO_REF1D

! MAPPING [-1, 1] TO PATCH
TYPE(FUNCTION_1D) FUNCTION REF_TO_LOCPATCH1D(REFX, LOCPATCH)

	REAL*8, INTENT(IN) :: REFX
	INTEGER, INTENT(IN) :: LOCPATCH
	
	REF_TO_LOCPATCH1D%VAL(0) = 0.10D0*(REFX + 2.0D0*LOCPATCH - 1.0D0)
	REF_TO_LOCPATCH1D%VAL(1) = 0.10D0
	REF_TO_LOCPATCH1D%VAL(2) = 0.0D0
	
END FUNCTION REF_TO_LOCPATCH1D


!!-------------------[[[[[ PATCH + 2*DELTA TO [-1, 1] OF PU DOMAIN ]]]]] ------------------------
TYPE(FUNCTION_1D) FUNCTION PATCH_TO_REFPU(PHYX, PATCH)

    REAL*8, INTENT(IN) :: PHYX
		INTEGER, INTENT(IN) :: PATCH
    REAL*8 :: XPTS(4)
		
		IF (NUMPATCH==1) THEN 
			PATCH_TO_REFPU%VAL(0) = 0.0D0
			PATCH_TO_REFPU%VAL(1) = 0.0D0
			GOTO 76
		ENDIF 
		
		IF (PATCH==1) THEN
			
			XPTS(1) = PATCHBDPT(PATCH,1) - 2.0D0*DELTA
			XPTS(2) = PATCHBDPT(PATCH,1)
			XPTS(3) = PATCHBDPT(PATCH,2) - DELTA
			XPTS(4) = PATCHBDPT(PATCH,2) + DELTA
			
			IF (PHYX>=XPTS(2) .AND. PHYX<=XPTS(3)) THEN
				PATCH_TO_REFPU%VAL(0) = 0.0D0
				PATCH_TO_REFPU%VAL(1) = 0.0D0
			ELSEIF (PHYX>=XPTS(3) .AND. PHYX<=XPTS(4)) THEN
				PATCH_TO_REFPU%VAL(0) = (PHYX-XPTS(3))/(XPTS(4)-XPTS(3))
				PATCH_TO_REFPU%VAL(1) = 1.0D0/(XPTS(4)-XPTS(3))
			ELSE 
				PATCH_TO_REFPU%VAL(0) = 5.0D0
				PATCH_TO_REFPU%VAL(1) = 0.0D0
			ENDIF
		ELSEIF (PATCH==NUMPATCH) THEN
		
			XPTS(1) = PATCHBDPT(PATCH,1) - DELTA
			XPTS(2) = PATCHBDPT(PATCH,1) + DELTA
			XPTS(3) = PATCHBDPT(PATCH,2)
			XPTS(4) = PATCHBDPT(PATCH,2) + 2.0D0*DELTA
		
			IF (PHYX>=XPTS(1) .AND. PHYX<=XPTS(2)) THEN
				PATCH_TO_REFPU%VAL(0) = (PHYX-XPTS(2))/(XPTS(2)-XPTS(1))
				PATCH_TO_REFPU%VAL(1) = 1.0D0/(XPTS(2)-XPTS(1))
			ELSEIF (PHYX>=XPTS(2) .AND. PHYX<=XPTS(3)) THEN
				PATCH_TO_REFPU%VAL(0) = 0.0D0
				PATCH_TO_REFPU%VAL(1) = 0.0D0
			ELSE 
				PATCH_TO_REFPU%VAL(0) = 5.0D0
				PATCH_TO_REFPU%VAL(1) = 0.0D0
			ENDIF
		ELSE
			XPTS(1) = PATCHBDPT(PATCH,1) - DELTA
			XPTS(2) = PATCHBDPT(PATCH,1) + DELTA
			XPTS(3) = PATCHBDPT(PATCH,2) - DELTA
			XPTS(4) = PATCHBDPT(PATCH,2) + DELTA
			
			IF (PHYX>=XPTS(1) .AND. PHYX<=XPTS(2)) THEN
				PATCH_TO_REFPU%VAL(0) = (PHYX-XPTS(2))/(XPTS(2)-XPTS(1))
				PATCH_TO_REFPU%VAL(1) = 1.0D0/(XPTS(2)-XPTS(1))
			ELSEIF (PHYX>=XPTS(2) .AND. PHYX<=XPTS(3)) THEN
				PATCH_TO_REFPU%VAL(0) = 0.0D0
				PATCH_TO_REFPU%VAL(1) = 0.0D0
			ELSEIF (PHYX>=XPTS(3) .AND. PHYX<=XPTS(4)) THEN
				PATCH_TO_REFPU%VAL(0) = (PHYX-XPTS(3))/(XPTS(4)-XPTS(3))
				PATCH_TO_REFPU%VAL(1) = 1.0D0/(XPTS(4)-XPTS(3))
			ELSE 
				PATCH_TO_REFPU%VAL(0) = 5.0D0
				PATCH_TO_REFPU%VAL(1) = 0.0D0
			ENDIF
		ENDIF

!     IF ((DABS(PHYX-XPTS(2)).LE.EPS) .OR. (DABS(PHYX-XPTS(3)).LE.EPS)) THEN
!       PATCH_TO_REFPU%VAL(0) = 0.0D0
!       PATCH_TO_REFPU%VAL(1) = 0.0D0
!     ENDIF
! 
!     IF ((DABS(PHYX-XPTS(1)).LE.EPS) .OR. (DABS(PHYX-XPTS(4)).LE.EPS)) THEN
! 			PATCH_TO_REFPU%VAL(0) = 0.0D0
!       PATCH_TO_REFPU%VAL(1) = 0.0D0
!     ENDIF
		
		76 CONTINUE
		PATCH_TO_REFPU%VAL(2) = 0.0D0
		
END FUNCTION PATCH_TO_REFPU


END MODULE PATCH_MAPPING

